<?php
// $Id$
/**
 * @file
 *  Enables map adminstrators to invite new members to maps.
 *
 * This module enables map administrators to invite new team members
 * to a map. It allows the administrator to add a user to multiple
 * maps in different roles, and to invite multiple users on a single
 * screen. The og_user_roles modules only allows the admin to add a
 * user to one role on one map at a time.
 *
 * Allowing a user/role the permission to use this module is
 * potentially dangerous. Depending on the roles that an inviter is
 * allowed to assign to a new invitee, it is possible for an inviter
 * without administrative priviledges to create an account with
 * administrative priviledges for themselves.
 *
 * :TODO: Write more input checking code for the results of $_POST in
 * group_invite_form_submit.
 * :TODO: This module appears to have been orignally written using a
 * lot of custom code. This should be transistioned into using the D6
 * Forms API. But beware custom JavaScript! It will take some AHAH
 * hackery to provide the same level of functionality the current
 * custom JS provides.
 * :TODO: This module was orginally coded under the assumption that
 * there is only one invitation per email address. However, this might
 * not be the case. The module needs to be rewritten to intelligently
 * handle an arbitrary number of invitations.
 * :TODO: Figure out where it makes sense to use the inviter's
 * language, where the organic group's language, and where the
 * invitee's language for display, emails, etc.
 */

/**
 * Implementation of hook_perm().
 */
function group_invite_perm() {
  return array('invite using group_invite', 'administer group_invite');
}

/**
 * Implementation of hook_menu().
 */
function group_invite_menu() {
  $items = array();
  $items['group_invite'] = array(
    'title' => 'Invite new team members',
    'page callback' => 'group_invite_create_group_invite_page',
    'type' => MENU_NORMAL_ITEM,
    'access arguments' => array('invite using group_invite'),
    );

  $items['group_invite/submit'] = array(
    'title' => 'Invite',
    'page callback' => 'group_invite_form_submit',
    'type' => MENU_CALLBACK,
    'access arguments' => array('invite using group_invite'),
    );

  $items['admin/settings/group_invite'] = array(
    'title' => 'Group Invite',
    'description' => 'Configure Group Invite settings.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('group_invite_admin_settings'),
    'access arguments' => array('administer group_invite'),
    'type' => MENU_NORMAL_ITEM, // optional
    );

  $items['group_invite/checkemail'] = array(
    'title' => 'Invite',
    'page callback' => 'group_invite_checkEmail',
    'type' => MENU_CALLBACK,
    'access arguments' => array('invite using group_invite'),
    );

  $items['group_invite/getRoles'] = array(
    'title' => 'Invite',
    'page callback' => 'group_invite_getRoles',
    'type' => MENU_CALLBACK,
    'access arguments' => array('invite using group_invite'),
    );

  // Create an "Invite New Members" tab on each og/users/%node page
  $items['og/users/%node/invite_users'] = array(
    'title' => 'Invite new members',
    'page callback' => 'group_invite_create_group_invite_page',
    'type' => MENU_LOCAL_TASK,
    'access callback' => 'og_is_group_admin',
    'access arguments' => array(2),
    'weight' => 5,
    );
  return $items;
}

function group_invite_cron() {
  $group_invite_timestamp = variable_get('group_invite_timestamp', '');
  // 2592000 = 30 days
  if ((time() - $group_invite_timestamp) >= 2592000) {
    db_query('DELETE FROM {group_invite} WHERE created < SUBDATE(NOW(),interval 30 day)');
    variable_set('group_invite_timestamp', time());
  }
}

/*
 * Ideally, this function would be replaced by a proper D6 Forms API
 * form with AHAH fanciness. However, the fancy custom JavaScript
 * would make it difficult. Please be careful when altering this
 * function. Be sure and test the group_invite/ page thoroughly
 * before and after altering it.
 */
function group_invite_create_group_invite_page() {
  global $user;
  // onChange='Drupal.onChange()'

  $js  = "var group_invite_new_team_member = '<fieldset class=\\'collapsible\\'><legend>". t('New team member') ."</legend>";
  $js .= "<label for=\\'email%NUM%\\'>". t('Email Address ') ."</label>";
  $js .= "<input type=\\'text\\' onblur=\\'checkEmail(this.value,%NUM%)\\' value=\\'\\' name=\\'user[%NUM%][email]\\' id=\\'email%NUM%\\' />";
  $js .= "<input type=\\'hidden\\'  value=\\'\\' name=\\'user[%NUM%][inDB]\\' id=\\'inDB%NUM%\\' />";

  $js .= "<div id=\\'DIVemail%NUM%\\'></div>";


  $js .= "<fieldset class=\\'collapsible\\'>";
  $js .= "<legend>". t('Select which map(s) to add the new user to');
  $js .= "</legend>";

  $result =  db_query("SELECT a.title,b.nid FROM {node} AS a LEFT JOIN {og_uid} AS b ON a.nid = b.nid WHERE a.type = 'green_map' AND b.uid = %d AND b.is_admin = '1'", $user->uid);
  while ($map = db_fetch_object($result)) {

    $js .= "<input type=\\'checkbox\\' onClick=\\'selectMap(\\\"". $map->nid ."\\\",\\\"%NUM%\\\")\\' value=\\'". $map->nid ."\\' name=\\'user[%NUM%][map][". $map->nid ."]\\' id=\\'". $map->nid ."map%NUM%\\' />";
    $js .= "<label for=\\'". $map->nid ."map%NUM%\\'>". $map->title ."</label>";

    $js .= "<div id=\\'DIV". $map->nid ."map%NUM%\\'></div>";

  }

  $js .= "</fieldset>";
  $js .= "</fieldset>";
  $js .= "';";

  // JS 2
  $js2  = "var group_invite_selectMap = '";
  $js2 .= "<fieldset class=\\'collapsible\\'>".
        "<legend> " . t('Role');
  $js2 .= "</legend>";

  $result =  db_query("SELECT * FROM {role}");
  while ($role = db_fetch_object($result)) {
    if (variable_get('group_invite_role_'. $role->rid, 0) == 0) {
      continue;
    }

    $js2 .= "<input type=\\'radio\\'  value=\\'". $role->rid ."\\' name=\\'user[%NUM%][map][%MNUM%]\\' id=\\'%MNUM%role%NUM%\\' ";
    if ($role->rid==5) {
      $js2 .= "checked" ;
    }
    $js2 .= "/>";
    $js2 .= "<label for=\\'%MNUM%role%NUM%\\'>". $role->name ."</label>";

  }
  $js2 .= "</fieldset>";
  $js2 .= "';";

  drupal_add_js($js, 'inline');
  drupal_add_js($js2, 'inline');
  $path = drupal_get_path('module', 'group_invite');
  drupal_add_js( 'misc/collapse.js' );
  drupal_add_js( $path .'/ajax.js');
  drupal_add_js( $path .'/group_invite.js', 'module', 'footer' );

  $content  = "<form action='". base_path() ."group_invite/submit' accept-charset='UTF-8' method='POST'>";
  $content .= "<div>";
  $content .= t('Write a message to accompany the email invitation that new members will receive');
  $content .= "</div>";
  $content .= "<textarea name='helloText' id='helloText' cols='60'>";
  $content .= t("@user has invited you to join their team on the Open Green Map.", array('@user' => $GLOBALS['user']->name));
  $content .= "</textarea>";
  $content .= "<div id='group_invite_content'></div>";
  $content .= "<div id = 'group_invite_add'><a href='#' onClick='Drupal.addFieldset()'>". t('Add another person') ."</a></div>";
  $content .= "<input type='submit' name='submit' value='Invite'/>";
  $content .= "</form>";
  return $content;
}

/*
 * Please be careful when altering this function. Be sure and test the
 * group_invite/ page thoroughly before and after altering it.
 */
function group_invite_checkEmail() {
  global $user;
  if (trim(arg(2)) == "") {
    die();
  }
  $email = trim(arg(2));
  if (!preg_match("/^[^@]+@[^@]+\.[a-z]{2,6}$/i", $email)) {
    // email string doesn't meet our requirements
    // have to be like (whateva)@(whateva).(2 - 6 characters)
    echo "ERROR";
    die();
  }
  $result =  db_query("SELECT uid FROM {users} WHERE mail = '%s';", $email);
  $c = db_fetch_object($result);
  if ($result && $c->uid) {
    // email is allerady in the DB
    if ($user->uid == $c->uid) {
      // it is forbidden users to change their own roles
      echo "ERROR2";
      die();
    }
    echo $c->uid;
  }
  else {
    // email isn't in the DB
    echo "FALSE";
  }
  die();
}

/*
 * Please be careful when altering this function. Be sure and test the
 * group_invite/ page thoroughly before and after altering it.
 */
function group_invite_getRoles() {
  global $user;
  if (trim(arg(2)) == "") {
    die();
  }
  $uid = trim(arg(2));
  $result =  db_query("SELECT DISTINCT (our.gid), our.rid FROM {og_users_roles} AS our INNER JOIN {og_uid} AS ou WHERE ou.uid = %d AND ou.is_admin = '1' AND our.uid= %d", $user->uid, $uid);
  $r = '';
  while ($c = db_fetch_object($result)) {
    // <mapNid:role>...
    $r .= "<". $c->gid .":". $c->rid .">";
  }
  echo $r;
  die();
}

function group_invite_admin_settings() {
  $form = array();
  $form['role_settings'] = array(
    '#type' => 'fieldset',
    '#title' => t('Role settings'),
    '#description' => t('What roles can map admins assign to map members.'),
    '#collapsible' => TRUE,
    );
  $result =  db_query("SELECT rid,name FROM {role}");
  while ($role = db_fetch_object($result)) {
  $form['role_settings']['group_invite_role_'. $role->rid] = array(
    '#type' => 'checkbox',
    '#title' => $role->name,
    '#return_value' => 1,
    '#default_value' => variable_get('group_invite_role_'. $role->rid, 0),
    );
  }
  return system_settings_form($form);
}

function group_invite_form_submit() {
  global $user;

  $invite_text_from_user = check_plain(trim(($_POST['helloText'])));
  foreach ($_POST['user'] as $new_user) {
    if ($new_user['inDB'] == 1) {
      $existing_user = user_load(array('mail' => trim($new_user['email'])));
      if ($user->uid == $existing_user->uid) {
        // Users should not be able to change their own roles.
        drupal_set_message(t('You cannot invite yourself to a group.'));
        continue;
      }
      $mail_language = user_preferred_language($existing_user);
      $mail_from = variable_get('site_mail', ini_get('sendmail_from'));
      $mail_to = $existing_user->mail;
      foreach ($new_user['map'] as $gid => $rid) {
        /*
         * The old code revoked all of the roles a user had in a group,
         * then added just the new role to that group, so I've
         * duplicated that functionality. However, doing so suggests
         * that roles within a group are mutually exclusive, which they
         * are not. The design of the form, with the use of a radio
         * buttons for choosing a role, also reflects a misunderstanding
         * of the non-exclusivity of roles.
         *
         * It might also reduce code complexity to insert new roles
         * for existing users into the group_invite table like they are
         * for users that are being invited to join the site. Then
         * they could be added to the user by the
         * g_i_user_register_action action, fired on the user "login"
         * hook.
         */
        og_user_roles_role_leave($existing_user->uid, $gid);
        og_user_roles_role_join($existing_user->uid, $rid, $gid);
        $db_results = db_query("SELECT title FROM {node} WHERE nid=%d", $gid);
        $mail_params['map'] = db_fetch_array($db_results);
        $mail_params['map']['link'] = "node/". $gid;
        $mail_success = drupal_mail('group_invite', 'existing_user', $mail_to, $mail_language, $mail_params, $mail_from);
      }
      drupal_set_message(t('Added new roles to the user %user', array('%user' => $new_user->name)));
      // Make possibly incorrect assumption that if the last email was
      // successfully sent, the rest of them were.
      if ($mail_success) {
        drupal_set_message(t('Invitation sent to %email', array('%email' => $mail_to)));
      }
      else {
        drupal_set_message(t('Unable to send invitation to %email', array('%email' => $mail_to)));
      }
    }
    // $new_user does not have an existing account.
    else {
      /*
       * Generate registration code that identifies this invitation in
       * the group_invite table, insert it into the table along with
       * the maps and roles the user is being assigned, then send an
       * invitation email to the user.
       */
      /*
       * The registration code does not have any random data in it, and
       * thus may be vulnerable to folks guessing the format and
       * duplicating the code for a known email address.
       */
      $registration_code = md5(date('l jS \of F Y h:i:s A') . $new_user['email']);
      foreach ($new_user['map'] as $gid => $rid) {
        $insert =  db_query("INSERT INTO {group_invite} (nid,code,rid,mail) VALUES (%d,'%s',%d,'%s');", $gid, $registration_code, $rid, $new_user['email']);
      }
      $mail_language = user_preferred_language($user);
      $mail_from = variable_get('site_mail', ini_get('sendmail_from'));
      $mail_to = filter_var($new_user['email'], FILTER_VALIDATE_EMAIL);
      if (!$mail_to) {
        drupal_set_message(t('Invalid email address %email.', array('%email' => $mail_to)));
        continue;
      }
      $mail_params['body'] = $invite_text_from_user;
      $mail_params['registration_code'] = $registration_code;
      $mail_success = drupal_mail('group_invite', 'new_user', $mail_to, $mail_language, $mail_params, $mail_from);

      if ($mail_success) {
        watchdog('user', 'Invitation mailed to @email by @user.', array('@email' => $mail_to, '@user' => $user->name));
        drupal_set_message(t('Invitation sent to %email', array('%email' => $mail_to)));
      }
      // watchdog call not needed as drupal_mail will issue one automatically.
      else {
        drupal_set_message(t('Unable to send invitation to %email.', array('%email' => $mail_to)));
      }
    }
  }
  /*
   * The goto at the end should probably have a conditional somewhere
   * and send the user to a different page if accessing the
   * group_invite module from the "Invite new users" tab on the group
   * page.
   */
  drupal_goto("group_invite");
}

function group_invite_form_alter(&$form, &$form_state, $form_id) {
  switch ($form_id) {
    case 'user_register':
    // Users should not be able to add themselves to maps when they
    // register. Remove the og_register elements.
    unset($form['og_register']);
    // if code is set and code meet code of DB, hide mail and set default value
    if (isset($_GET['code']) && count($form['#post']) == 0) {
      // check_plain doesn't escape SQL special characters, so this still
      // needs to be passed as a parameter to db_query()
      $get_code = check_plain(trim($_GET['code']));
      $query_results =  db_query("SELECT nid,mail FROM {group_invite} WHERE code = '%s'", $get_code);
      /*
       * :TODO: This module was orginally coded under the assumption
       * that there would only ever be one invitation per email address.
       * Thus, we should check to see if there is more than one result
       * and throw an error if there is.
       */
      $group_invitee = db_fetch_object($query_results);
      if (!$query_results || !$group_invitee->nid) {
        return;
      }
      // Is adding the email address of someone an appropriate way to
      // communicate the invitation back to the server? It seems like
      // we should verify the email address and code in this part,
      // pass the code to the next step via hidden variable, then
      // verify the email-code pair before actually assigning the roles.
      $form['mail']['#type'] = 'hidden';
      $form['mail']['#default_value'] = $group_invitee->mail;
    }
    break;
    case 'green_map_node_form':
      unset($form['og_user_roles_logo']);
      unset($form['og_user_roles_links_gid']);
      unset($form['og_user_roles_nopublic_gid']);
      break;
  }
}

/**
 * Implementation of hook_action_info().
 *
 * This action must be selected for "User Registration" under
 * "Triggers->Users"
 */
function group_invite_action_info() {
  return array(
    'group_invite_user_register_action' => array(
      'description' => t('Assign permissions at account creation for new users invited to existing maps by existing users'),
      'type' => 'user',
      'configurable' => FALSE,
      'hooks' => array(
        'user' => array('insert'),
      ),
    ),
  );
}

/**
 * Implementation of Drupal action. This should be triggered on
 * user registration.
 */
function group_invite_user_register_action(&$object, $context = array()) {
  if (isset($object->uid)) {
    $uid = $object->uid;
  }
  elseif (isset($context['uid'])) {
    $uid = $context['uid'];
  }
  else {
    global $user;
    $uid = $user->uid;
  }
  $query_results =  db_query("SELECT uid,mail FROM {users} WHERE uid = %d", $uid);
  if (!$query_results) {
    watchdog('error', 'Problem with db_query.', NULL);
    drupal_set_message(t('Problem with database query'));
    return;
  }
  $c = db_fetch_object($query_results);
  // if no matches, this is not first login or username don't match with DB.
  if (!$c) {
    watchdog('error', 'Problem with db_query, no matches found.', NULL);
    drupal_set_message(t('Problem with database query: no matches found'));
    return;
  }

  // when user is loggin in first time
  $result =  db_query("SELECT DISTINCT nid, rid FROM {group_invite} WHERE mail = '%s'", $c->mail);
  if (!$result) {
    watchdog('error', 'Problem with db_query. table: group_invite', NULL);
    drupal_set_message(t('Problem with database query'));
    return;
  }

  $ul = user_load(array('uid' => $c->uid));
  $arr = array();
  $arr['roles']= $ul->roles;

  while ($ids = db_fetch_object($result)) {
    og_save_subscription($ids->nid, $c->uid, array('is_active' => TRUE));
    og_user_roles_role_leave($c->uid, $ids->nid);
    // then insert new roles to the group
    og_user_roles_role_join($c->uid, $ids->rid, $ids->nid);
    $arr['roles'][$ids->rid]= $ids->rid;
    db_query("DELETE FROM {group_invite} WHERE mail = '%s' AND nid = %d AND rid = %d", $c->mail, $ids->nid, $ids->rid);
  }
  user_save($ul, $arr);
  //roles will be modified only if user is invited (requilar registeration doesn't modify anything)
}

function group_invite_mail($key, &$message, $params) {
  global $user;

  $language = $message['language'];
  $variables = user_mail_tokens($params, $language);
  // Invitations have links in them, so make them HTML emails.
  $message['headers']['Content-Type'] = 'text/html; charset=UTF-8; format=flowed';
  $link_params = array(
    'absolute' => TRUE,
  );
  switch ($key) {
    case 'new_user':
      $link_params['query'] = "code=". $params['registration_code'];
      $link = l(t("Open Green Map"), "user/register", $link_params);
      $link_text = "You can join ". $link ." to see the map.";
      $message['subject'] = t('Invitation to !site', $variables, $language->language);
      $message['body'][] = "<p>". $params['body'] ."</p>";
      $message['body'][] = "<p>". $link_text ."</p>";
      break;
    case 'existing_user':
      $map_link = l(t($params['map']['title'], $variables, $language->language), $params['map']['link'] , $link_params);
      $ogm_link = l(t('!site', $variables, $language->language), '<front>', $link_params);
      // Munge reply-to header. Is this a good (or RFC compliant) idea?
      $message['headers']['Reply-To'] = $user->mail;
      $message['subject'] = t('You have been added to a new map at !site', $variables, $language->language);
      $message['body'][] = "<p>". $user->name ." has added you to the ". $map_link ." at ". $ogm_link ."</p>";
      $message['body'][] = "<p>If you have any questions or comments, please email ". $user->mail ."</p>";
      break;
  }
}
