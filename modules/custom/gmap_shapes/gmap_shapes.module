<?php
// $Id$


/**
* Display help and module information
* @param path whitch path of the site we're displaying help
* @param arg array that holds the current path as vould be returned from arg() function
* @return help text for the path
*/
function gmap_shapes_help($path){
  $output = '';
  switch($path){
	case "admin/modules#gmap_shapes":
    case "admin/help#gmap_shapes":
   // $output = '<p>'. t("Displays links to created on this date") . '</p>';
    break;
	case "user/help#gmap_shapes":
	break;
  }
  return $output;
} // function gmap_shapes

/**
* Valid permissions for this module
* @return array An array of valid permissions for the gmap_shapes module
*/
function gmap_shapes_perm() {
  return array('access gmap_shapes content');
}

/**
 * Implementation of hook_field_info().
 */
function gmap_shapes_field_info() {
  return array(
    'gmap_shapes' => array('label' => t('GoogleMap Shapes')),
   );
}


/**
 * Implementation of hook_field_settings().
 */
function gmap_shapes_field_settings($op, $field) {
  switch ($op) {
    case 'database columns':
      $columns = array(
        'gmap_shapes' => array('type' => 'GEOMETRY'),
      );
      return $columns;
  }
}


/**
 * Implementation of hook_field().
 */
function gmap_shapes_field($op, &$node, $field, &$node_field, $teaser, $page) {
  $db_info = content_database_info($field);
  switch ($op) {
    case 'insert':
    case 'update':
		// save
		if ($field['widget']['type'] == 'gmap_shapes') {
				$data = $_SESSION['gmap_shapes_save_data'];
				if ($field['multiple']) {
					// TODO: multiple field behavior
				} else {
					if (db_result(db_query('SELECT COUNT(*) FROM {'. $db_info['table'] .'} WHERE vid = %d AND nid = %d', $node->vid, $node->nid))) {
            			db_query("UPDATE {". $db_info['table'] ."} SET ". $db_info['columns']['gmap_shapes']['column'] ." = GeomFromText('POLYGON((".$data."))') WHERE vid = %d AND nid = %d", $node->vid, $node->nid);
          			} else {
            			db_query("INSERT INTO {". $db_info['table'] ."} (". $db_info['columns']['gmap_shapes']['column'] .", vid, nid) VALUES (GeomFromText('POLYGON((".$data."))') , %d, %d)", $node->vid, $node->nid);
          			}
				}
				// I kill it
				$_SESSION['gmap_shapes_save_data'] = '';
				$_SESSION['gmap_shapes_save_data'] = null;
				unset($_SESSION['gmap_shapes_save_data']);
				session_unregister('gmap_shapes_save_data');
		}
	break;
  }
}

/**
 * Implementation of hook_widget_info().
 */
function gmap_shapes_widget_info() {
  return array(
    'gmap_shapes' => array(
      'label' => 'Textfield',
      'field types' => array('gmap_shapes'),
    ),
  );
}

/**
 * Implementation of hook_widget().
 */
// this is a field while creating new content
function gmap_shapes_widget($op, &$node, $field, &$items) {
  $db_info = content_database_info($field);
  switch ($op) {
  	
	// "form": The node is being edited, and a form should be prepared for display to the user.
    case 'form':
      $form = array();
      $form[$field['field_name']] = array(
        '#tree' => TRUE, 
        '#weight' => $field['widget']['weight'],
      );
	  
      if ($field['widget']['type'] == 'gmap_shapes') {
        // issue with multiple values?? how we should deal with them?
		
		// single value
		if ($field['multiple']) {
			//TODO: multiple fields features	
		}else {
			
  			$form[$field['field_name']]['gmap_user'] = array(
    			'#type'=>'markup',
    			'#value'=>''
    		);
    
  			$form[$field['field_name']]['gmap_user']['#value'] = gmap_set_location(
  				variable_get('gmap_user_map', '[gmap|id=usermap|center=0,30|control=Large|zoom=16|width=100%|height=400px]'),
            ($lon = $_GET['edit']['gmap_longitude'] ? $_GET['edit']['gmap_longitude'] : $user->longitude),
            ($lat = $_GET['edit']['gmap_latitude'] ? $_GET['edit']['gmap_latitude'] : $user->latitude));
			
			// default value for shape textfield
			if($node->nid){
				
				$q = "SELECT AsText(".$db_info['columns']['gmap_shapes']['column'].") AS value FROM {".$db_info['table']."} where vid = %d AND nid = %d";
				$result = db_query($q,$node->vid, $node->nid);
				$row = db_fetch_object($result);
				preg_match_all("/([^,( ]+)[ ]+([^,) ]+)/",$row->value,$matches,PREG_SET_ORDER);
				$data  = "<?xml version='1.0' encoding='UTF-8'?>\n" .
						 "<kml>\n" .
						 "<Document>\n" .
						 "<Placemark>\n" .
						 "<Polygon>\n" .
						 "<outerBoundaryIs>\n" .
						 "<LinearRing>\n" .
						 "<coordinates>\n";
				for($i =0;$i < count($matches);$i++){
						if($i != 0){$data .= " ";}
						$data .= $matches[$i][1] . "," . $matches[$i][2];
				}
				
				$data .= "</coordinates>\n" .
						 "</LinearRing>\n" .
						 "</outerBoundaryIs>\n" .
						 "</Polygon>\n" .
						 "</Placemark>\n" .
						 "</Document>\n" .
						 "</kml>\n";
						 
				$shape_textfield_default_value = $data;
			}else {
				$shape_textfield_default_value = "";
			}
			
			// shape textfield
			$form[$field['field_name']][0]['gmap_shapes'] = array(
        	  '#type' => 'textarea',
        	  '#title' => $field['widget']['label'],
			  '#id' => 'gmap_shapes_textfield',
			//  '#disabled' => TRUE,
        	  '#default_value' => $shape_textfield_default_value,
        	  '#required' => $field['required'] ? $field['required'] : FALSE,
        	  '#size' => isset($field['widget']['size']) ? $field['widget']['size'] : 60,
        	  '#description' => isset($field['widget']['description']) ? $field['widget']['description'] : '',
        	);
		}
		// add javascript
		drupal_add_js(drupal_get_path('module', 'gmap_shapes') . '/shapes.js');
      }
      return $form;
	  
	// "submit": The user has just finished editing the node and the node has passed validation. This hook can be used to modify the node.
	case 'submit':
		if ($field['widget']['type'] == 'gmap_shapes') {
			if($node->{$field['field_name']}[0]['gmap_shapes'] != ''){
				$shape = parseXMLToArray($node->{$field['field_name']}[0]['gmap_shapes']);
				// first we are looking for a polygons
				$polygons = _getShapeArraysByTagname('POLYGON',$shape);
				// saves only the firs one of the polygons
				$coordinates = _getShapeArraysByTagname('COORDINATES',$polygons[0]);
				
				// we haveto put data to mysql recognisable format
				preg_match_all("/([^, ]+),([^, ]+)/",$coordinates[0]['value'],$matches,PREG_SET_ORDER);
				$data = '';
				for($i =0;$i < count($matches);$i++){
						if($i != 0){$data .= ",";}
						$data .= $matches[$i][1] . " " . $matches[$i][2];
				}
				$node->{$field['field_name']}[0]['gmap_shapes'] = $data;
				$items[0]['gmap_shapes'] = $data;
				
				
				$items = array();
				$_SESSION['gmap_shapes_save_data'] = $data;
			}
		}
		
		
	return;
  }
}


/**
 * parseXMLToArray
 * @param $data String
 * @return array
 * This function parses given XML data to the array where tree format still exists. 
 */
function parseXMLToArray($data) {
	
		$a = array();
	  	$xml_parser = xml_parser_create();
		/* 
		 * xml_parser = parser, 
		 * data = data to be parsed, 
		 * vals = array which will contain value-data after this function call, 
		 * index = array which will contain index-data after this function call
		 */
	  	xml_parse_into_struct($xml_parser, $data, $vals, $index);
		xml_parser_free($xml_parser);

		// st = root of the whole array
		$st = array('childs' => array());
		$parent = &$st; // parent = parent array of current element
		$parent_stack = array(); // stack of the parent arrays (needed when closing elements)
		$parent_stack[] = &$parent;

		foreach ($vals as $xml_elem) {
			
			if($xml_elem['type'] == "open") {
				$ind = count($parent['childs']);
				
				$parent['childs'][$ind] = array(
				'tag' => $xml_elem['tag'],
				'value' => $xml_elem['value'],
				'childs' => array(),
				);
				
				// attributes for the element
       			if ($xml_elem['attributes']) {
       				$parent['childs'][$ind]['attributes'] = array();
           			foreach($xml_elem['attributes'] as $attrKey => $attrVal){
           				$parent['childs'][$ind]['attributes'][$attrKey] = $attrVal;
           			}
       			}
				// when element is open we make it a parent item and add it to the stack
				// we are not using array_push because we need a link to the original array not just a copy of it
				$parent = &$parent['childs'][$ind];
				$parent_stack[] = &$parent;
				        
     		} elseif($xml_elem['type'] == "close") {
				// we do not want to use array_pop method to get parent element because we need a link to the original array not just a copy of it
				array_pop($parent_stack);
				$parent = &$parent_stack[count($parent_stack)-1];
				
     		} elseif($xml_elem['type'] == "complete") {
				$ind = count($parent['childs']);
				
				$parent['childs'][$ind] = array(
				'tag' => $xml_elem['tag'],
				'value' => $xml_elem['value'],
				// complete elements are leaves so we don't need 'childs' array
				);
				
				// attributes for the element
       			if ($xml_elem['attributes']) {
       				$parent['childs'][$ind]['attributes'] = array();
           			foreach($xml_elem['attributes'] as $attrKey => $attrVal){
           				$parent['childs'][$ind]['attributes'][$attrKey] = $attrVal;
           			}
       			}
     		}
			
   		}
		//$a = $st['childs'];
		$a = $st;
		return $a;

}
/**
 * _getShapeArraysByTagname
 * @return Array on success else FALSE
 * @param $tag String
 * @param $array Array
 * @param $r Array[optional]
 * Iterative function which returns an array of all arrays with requested tag
 */
function _getShapeArraysByTagname($tag, $array, &$r = array()){
	
	// if given array is not an array return false
	if(!is_array($array)){
		return FALSE;
	}
	
	// if given array is empty it is useless to continue
	if(count($array) == 0){
		return FALSE;
	}
	
	// if current array matches we add it to the return array
	if(isset($array['tag']) && strtoupper($array['tag']) == strtoupper($tag)) {
		$r[] = $array;
	}
	
	// we are reading each of the childs through
	if(is_array($array['childs'])){
		while(list($k,$v) = each($array['childs'])){
			// iteration
			_getShapeArraysByTagname($tag, $array['childs'][$k], $r);
		}
	}
	
	// if no matches return false
	if(count($r) == 0){
		return FALSE;
	} else {
		return $r;
	}
}

/**
 * Implementation of hook_field_formatter_info().
 *
 */
function gmap_shapes_field_formatter_info() {
  return array(
    'default' => array(
      'label' => 'Default Gmap Shape',
      'field types' => array('gmap_shapes'),
    ),
  );
}


/*
 select * from shape where MBRIntersects(data,GeomFromText('LineString(4 4,5 5)'));
 */


