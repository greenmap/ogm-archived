<?php
// $Id$


/**
* Display help and module information
* @param path whitch path of the site we're displaying help
* @param arg array that holds the current path as vould be returned from arg() function
* @return help text for the path
*/
function gmap_shapes_help($path){
  $output = '';
  switch($path){
	case "admin/modules#gmap_shapes":
    case "admin/help#gmap_shapes":
   // $output = '<p>'. t("Displays links to created on this date") . '</p>';
    break;
	case "user/help#gmap_shapes":
	break;
  }
  return $output;
} // function gmap_shapes

/**
* Valid permissions for this module
* @return array An array of valid permissions for the gmap_shapes module
*/
function gmap_shapes_perm() {
  return array('access gmap_shapes content');
}

/**
 * Implementation of hook_field_info().
 */
function gmap_shapes_field_info() {
  return array(
    'gmap_shapes' => array('label' => t('GoogleMap Shapes')),
   );
}


/**
 * Implementation of hook_field_settings().
 */
function gmap_shapes_field_settings($op, $field) {
  switch ($op) {
    case 'database columns':
      $columns = array(
        'gmap_shapes' => array('type' => 'GEOMETRY'),
      );
      return $columns;
  }
}


/**
 * Implementation of hook_field().
 */
function gmap_shapes_field($op, &$node, $field, &$node_field, $teaser, $page) {
  $db_info = content_database_info($field);
  switch ($op) {
    case 'insert':
    case 'update':
		// save if it's not a point, otherwise ignore
		if ($field['widget']['type'] == 'gmap_shapes') {
        // TT - ***********  -  @FIX - this is a horrible security risk from Miika's code, but i've no idea how to improve. Run through some kind of input check?
        // putting code that a user can mess with directly into the databse is really bad.
				$data = $_SESSION['gmap_shapes_save_data'];
        $data = check_plain($data); // a slight security improvement, stops xss on IE6 at least
        $data_type = $_SESSION['gmap_shapes_type'];
        if(check_plain($data_type) == 'line'){
          $input_type = 'linestring';
        } else {
          $input_type = 'polygon'; 
        }

        if($data){
          // if there's any shape/line data then put it in the database
  				if ($field['multiple']) {
  					// TODO: multiple field behavior
  				} else {
            // how to tell between POLYGON and LINESTRING for geomfromtext
            if($input_type == 'polygon'){
    					if (db_result(db_query('SELECT COUNT(*) FROM {'. $db_info['table'] .'} WHERE vid = %d AND nid = %d', $node->vid, $node->nid))) {
                db_query("UPDATE {". $db_info['table'] ."} SET ". $db_info['columns']['gmap_shapes']['column'] ." = GeomFromText('POLYGON((".$data."))') WHERE vid = %d AND nid = %d", $node->vid, $node->nid);
              } else {
                db_query("INSERT INTO {". $db_info['table'] ."} (". $db_info['columns']['gmap_shapes']['column'] .", vid, nid) VALUES (GeomFromText('POLYGON((".$data."))') , %d, %d)", $node->vid, $node->nid);
              }
            } else if($input_type == 'linestring'){
    					if (db_result(db_query('SELECT COUNT(*) FROM {'. $db_info['table'] .'} WHERE vid = %d AND nid = %d', $node->vid, $node->nid))) {
                db_query("UPDATE {". $db_info['table'] ."} SET ". $db_info['columns']['gmap_shapes']['column'] ." = GeomFromText('LINESTRING(".$data.")') WHERE vid = %d AND nid = %d", $node->vid, $node->nid);
              } else {
                db_query("INSERT INTO {". $db_info['table'] ."} (". $db_info['columns']['gmap_shapes']['column'] .", vid, nid) VALUES (GeomFromText('LINESTRING(".$data.")') , %d, %d)", $node->vid, $node->nid);
              }
            }
  				}
        }
				// Empty the relevent sessions information
				$_SESSION['gmap_shapes_save_data'] = '';
				$_SESSION['gmap_shapes_save_data'] = null;
				unset($_SESSION['gmap_shapes_save_data']);
				session_unregister('gmap_shapes_save_data');
        $_SESSION['gmap_shapes_type'] = '';
				$_SESSION['gmap_shapes_type'] = null;
				unset($_SESSION['gmap_shapes_type']);
				session_unregister('gmap_shapes_type');
        // TT - Unset the contents of the field so that the default CCK module doesn't mess with it
        $node_field = NULL;
        $field = NULL;
		}
	break;
  }
}

/**
 * Implementation of hook_widget_info().
 */
function gmap_shapes_widget_info() {
  return array(
    'gmap_shapes' => array(
      'label' => 'Textfield',
      'field types' => array('gmap_shapes'),
    ),
  );
}

/**
 * Implementation of hook_widget().
 */
// this is a field while creating new content
function gmap_shapes_widget($op, &$node, $field, &$items) {
  $db_info = content_database_info($field);
  switch ($op) {
  	
	// "form": The node is being edited, and a form should be prepared for display to the user.
    case 'form':
      // check if we've got a shape
      $shape = NULL;
      if($node->nid){
        $shape = gmap_shapes_identify_type($node->taxonomy);
      }
      if($_GET[poly] == 'line'){ $shape = 'line'; }
      else if($_GET[poly] == 'area'){ $shape = 'area'; }
      
      // build form for widget
      $form = array();
      $form[$field['field_name']] = array(
        '#tree' => TRUE, 
        '#weight' => $field['widget']['weight'],
      );
	  
      if ($field['widget']['type'] == 'gmap_shapes') {
        // issue with multiple values?? how we should deal with them?
    		
    		// single value
    		if ($field['multiple']) {
    			//TODO: multiple fields features	
    		}else {
    			
            // TT - create a field to choose between point, line, or shape
            $form[$field['field_name']]['gmap_type'] = array(
        			'#type' => 'radios',
        			'#title' => t('What are you adding'), 
              '#default_value' => $shape ? $shape : 'point',
              '#id' => 'gmap_type_radios',
              '#attributes' => array('class' => 'gmap_type_radios'),
              '#options' => array(
                'point' => t('A Site'),
                'line' => t('A Line'),
                'area' => t('An Area'),
              ),
              
        		);    		
            // add javascript
            drupal_add_js(drupal_get_path('module', 'gmap_shapes') . '/shapes_switcher.js');
            
            
            // TT - If user has selected shape or line, then show the map & shapefile field, else hide
            
            if($shape){
              // add javascript
              drupal_add_js(drupal_get_path('module', 'gmap_shapes') . '/shapes.js');
              // holder for the map
        			$form[$field['field_name']]['gmap_user'] = array(
          			'#type'=>'markup',
          			'#value'=>''
          		);
              
           
              
        			$form[$field['field_name']]['gmap_user']['#value'] = gmap_set_location(
        				variable_get('gmap_user_map', '[gmap|id=usermap|center=0,30|control=Large|zoom=16|width=100%|height=400px]'),
                  ($lon = $_GET['edit']['gmap_longitude'] ? $_GET['edit']['gmap_longitude'] : $user->longitude),
                  ($lat = $_GET['edit']['gmap_latitude'] ? $_GET['edit']['gmap_latitude'] : $user->latitude));
        			
        			// default value for shape textfield
        			if($node->nid){
        				
        				$q = "SELECT AsText(".$db_info['columns']['gmap_shapes']['column'].") AS value FROM {".$db_info['table']."} where vid = %d AND nid = %d";
        				$result = db_query($q,$node->vid, $node->nid);
        				$row = db_fetch_object($result);
        				preg_match_all("/([^,( ]+)[ ]+([^,) ]+)/",$row->value,$matches,PREG_SET_ORDER);
                
                // TODO ********** FIX for lines
                
                if($shape == 'area') {
                  
          				$data  = "<?xml version='1.0' encoding='UTF-8'?>\n" .
          						 "<kml>\n" .
          						 "<Document>\n" .
          						 "<Placemark>\n" .
          						 "<Polygon>\n" .
          						 "<outerBoundaryIs>\n" .
          						 "<LinearRing>\n" .
          						 "<coordinates>\n";
          				for($i =0;$i < count($matches);$i++){
          						if($i != 0){$data .= " ";}
          						$data .= $matches[$i][1] . "," . $matches[$i][2];
          				}
          				
          				$data .= "</coordinates>\n" .
          						 "</LinearRing>\n" .
          						 "</outerBoundaryIs>\n" .
          						 "</Polygon>\n" .
          						 "</Placemark>\n" .
          						 "</Document>\n" .
          						 "</kml>\n";
                       
                } else {
                
           				$data  = "<?xml version='1.0' encoding='UTF-8'?>\n" .
          						 "<kml>\n" .
          						 "<Document>\n" .
          						 "<Placemark>\n" .
          						 "<LineString>\n" .
          						 "<coordinates>\n";
          				for($i =0;$i < count($matches);$i++){
          						if($i != 0){$data .= " ";}
          						$data .= $matches[$i][1] . "," . $matches[$i][2];
          				}
          				
          				$data .= "</coordinates>\n" .
          						 "</LineString>\n" .
          						 "</Placemark>\n" .
          						 "</Document>\n" .
          						 "</kml>\n";      
                       
                }
        						 
        				$shape_textfield_default_value = $data;
        			}else {
        				$shape_textfield_default_value = "";
        			}
        			
        			// shape textfield
        			$form[$field['field_name']][0]['gmap_shapes'] = array(
                	  '#type' => 'textarea',
                	  '#title' => $field['widget']['label'],
                    '#id' => 'gmap_shapes_textfield',
                    //  '#disabled' => TRUE,
                	  '#default_value' => $shape_textfield_default_value,
                	  '#required' => $field['required'] ? $field['required'] : FALSE,
                	  '#size' => isset($field['widget']['size']) ? $field['widget']['size'] : 60,
                	  '#description' => isset($field['widget']['description']) ? $field['widget']['description'] : '',
                	);
            }
    		}

      }
      return $form;
	  
	// "submit": The user has just finished editing the node and the node has passed validation. This hook can be used to modify the node.
	case 'submit':
		if ($field['widget']['type'] == 'gmap_shapes') {
			if($node->{$field['field_name']}[0]['gmap_shapes'] != ''){
				$shape = parseXMLToArray($node->{$field['field_name']}[0]['gmap_shapes']);
				// first we are looking for a polygons
				$polygons = _getShapeArraysByTagname('POLYGON',$shape);
				
        // now look for lines
        $lines = _getShapeArraysByTagname('LINESTRING',$shape);
        
        if($polygons){
          // saves only the firs one of the polygons
          $coordinates = _getShapeArraysByTagname('COORDINATES',$polygons[0]);
          $_SESSION['gmap_shapes_type'] = 'polygon';
        } else if ($lines) {
          $coordinates = _getShapeArraysByTagname('COORDINATES',$lines[0]);
          $_SESSION['gmap_shapes_type'] = 'line';
        }
        
				// we haveto put data to mysql recognisable format
				preg_match_all("/([^, ]+),([^, ]+)/",$coordinates[0]['value'],$matches,PREG_SET_ORDER);
				$data = '';
				for($i =0;$i < count($matches);$i++){
						if($i != 0){$data .= ",";}
						$data .= $matches[$i][1] . " " . $matches[$i][2];
				}

				$node->{$field['field_name']}[0]['gmap_shapes'] = $data;
				$items[0]['gmap_shapes'] = $data;
				
				
				$items = array();
				$_SESSION['gmap_shapes_save_data'] = $data;
        
        $field = NULL;
        $items = NULL;

			}
		}
		
		
	return;
  }
}


/**
 * parseXMLToArray
 * @param $data String
 * @return array
 * This function parses given XML data to the array where tree format still exists. 
 */
function parseXMLToArray($data) {
	
		$a = array();
	  	$xml_parser = xml_parser_create();
		/* 
		 * xml_parser = parser, 
		 * data = data to be parsed, 
		 * vals = array which will contain value-data after this function call, 
		 * index = array which will contain index-data after this function call
		 */
	  	xml_parse_into_struct($xml_parser, $data, $vals, $index);
		xml_parser_free($xml_parser);

		// st = root of the whole array
		$st = array('childs' => array());
		$parent = &$st; // parent = parent array of current element
		$parent_stack = array(); // stack of the parent arrays (needed when closing elements)
		$parent_stack[] = &$parent;

		foreach ($vals as $xml_elem) {
			
			if($xml_elem['type'] == "open") {
				$ind = count($parent['childs']);
				
				$parent['childs'][$ind] = array(
				'tag' => $xml_elem['tag'],
				'value' => $xml_elem['value'],
				'childs' => array(),
				);
				
				// attributes for the element
       			if ($xml_elem['attributes']) {
       				$parent['childs'][$ind]['attributes'] = array();
           			foreach($xml_elem['attributes'] as $attrKey => $attrVal){
           				$parent['childs'][$ind]['attributes'][$attrKey] = $attrVal;
           			}
       			}
				// when element is open we make it a parent item and add it to the stack
				// we are not using array_push because we need a link to the original array not just a copy of it
				$parent = &$parent['childs'][$ind];
				$parent_stack[] = &$parent;
				        
     		} elseif($xml_elem['type'] == "close") {
				// we do not want to use array_pop method to get parent element because we need a link to the original array not just a copy of it
				array_pop($parent_stack);
				$parent = &$parent_stack[count($parent_stack)-1];
				
     		} elseif($xml_elem['type'] == "complete") {
				$ind = count($parent['childs']);
				
				$parent['childs'][$ind] = array(
				'tag' => $xml_elem['tag'],
				'value' => $xml_elem['value'],
				// complete elements are leaves so we don't need 'childs' array
				);
				
				// attributes for the element
       			if ($xml_elem['attributes']) {
       				$parent['childs'][$ind]['attributes'] = array();
           			foreach($xml_elem['attributes'] as $attrKey => $attrVal){
           				$parent['childs'][$ind]['attributes'][$attrKey] = $attrVal;
           			}
       			}
     		}
			
   		}
		//$a = $st['childs'];
		$a = $st;
		return $a;

}
/**
 * _getShapeArraysByTagname
 * @return Array on success else FALSE
 * @param $tag String
 * @param $array Array
 * @param $r Array[optional]
 * Iterative function which returns an array of all arrays with requested tag
 */
function _getShapeArraysByTagname($tag, $array, &$r = array()){
	
	// if given array is not an array return false
	if(!is_array($array)){
		return FALSE;
	}
	
	// if given array is empty it is useless to continue
	if(count($array) == 0){
		return FALSE;
	}
	
	// if current array matches we add it to the return array
	if(isset($array['tag']) && strtoupper($array['tag']) == strtoupper($tag)) {
		$r[] = $array;
	}
	
	// we are reading each of the childs through
	if(is_array($array['childs'])){
		while(list($k,$v) = each($array['childs'])){
			// iteration
			_getShapeArraysByTagname($tag, $array['childs'][$k], $r);
		}
	}
	
	// if no matches return false
	if(count($r) == 0){
		return FALSE;
	} else {
		return $r;
	}
}

/**
 * Implementation of hook_field_formatter_info().
 *
 */
function gmap_shapes_field_formatter_info() {
  return array(
    'default' => array(
      'label' => 'Default Gmap Shape',
      'field types' => array('gmap_shapes'),
    ),
  );
}


/*
 select * from shape where MBRIntersects(data,GeomFromText('LineString(4 4,5 5)'));
 */


 
 
 
/**
 *	hook_form_alter()
 *
 *	If the user has selected to add a line or area, then we need to hide normal location form
 */
function gmap_shapes_form_alter($form_id, &$form){
	switch ($form_id) {
		case 'green_site_node_form':
      $shape = NULL;
      // if we're editing a form, check if it's a shape
      if($form['#node']->nid){
        $shape = gmap_shapes_identify_type($form['#node']->taxonomy);
      }
      if($_GET[poly] == 'point'){
        $js = "var poly_type = 'point';";
        drupal_add_js($js, 'inline');
        // hide non-used taxonomies
        $form['taxonomy']['5'] = NULL;
        // TODO secondary
        
      } else if($_GET[poly] == 'line' || $_GET[poly] == 'area' || $shape){
        // print_r($form);
        if($_GET[poly] == 'line' || $shape == 'line'){
          $js = "var poly_type = 'line';";
          drupal_add_js($js, 'inline');
        } else {
          $js = "var poly_type = 'area';";
          drupal_add_js($js, 'inline');
        }
        
        //  hide the wrong taxonomies, make required primaryicon not required
        // TODO ****
        
        // hide the default location form
        $form['locations']=NULL;
        // deal with location error
        // TODO ****
        
      } else {
        $js = "var poly_type = 'point';";
        drupal_add_js($js, 'inline');
        // hide non-used taxonomies
        $form['taxonomy']['5'] = NULL;
        // TODO secondary
      }
      
			break;
	}
}
 
/* this figures out if we've got a line or polygon based on the node's taxonomy
* @param taxonomy - an array containing objects with tid, vid, etc
* @return - $shape - a string - either 'line' or 'area'
*/

function gmap_shapes_identify_type($taxonomy){
  foreach($taxonomy as $tid => $term){
    if($term->vid == 5){
      $term_tid = $tid;
      break;
    }
  }
  $parents = taxonomy_get_parents($term_tid); // an array of parent term objects
  foreach($parents as $parent){
    $parent_term = taxonomy_get_parents($parent->tid);
  }
  
  $parent_term = array_values($parent_term);
  
  if ($parent_term[0]->tid == 306){
    return 'area';
  } elseif ($parent_term[0]->tid == 305){
    return 'line';
  } else {
    return NULL;
  }
  
}