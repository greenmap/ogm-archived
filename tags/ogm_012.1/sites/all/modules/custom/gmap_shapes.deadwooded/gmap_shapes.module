<?php
// $Id$


/* TODO Automatically add Drupal.settings.basePath
   In Drupal 5, you would have to add the base path to Drupal.settings yourself
   if you needed it (it's needed for just about every AHAH/AJAX enabled module
   if you did it right). Now in Drupal 6, it's added automatically. You can always
   find it at Drupal.settings.basePath (actually, as soon as drupal_add_js() is
   called at least once, so this is similar to the way we automatically add
   drupal.js and jquery.js. */

/* TODO FormAPI image buttons are now supported.
   FormAPI now offers the 'image_button' element type, allowing developers to
   use icons or other custom images in place of traditional HTML submit buttons.

$form['my_image_button'] = array(
  '#type'         => 'image_button',
  '#title'        => t('My button'),
  '#return_value' => 'my_data',
  '#src'          => 'my/image/path.jpg',
); */

/* TODO Remove $row argument from db_result() method
   The $row argument of db_result() was removed from the database abstraction
   layer in 6.x core, as it was a database dependent option. Developers need to
   use other handling to replace the needs of this method. */

/* TODO New user_mail_tokens() method may be useful.
   user.module now provides a user_mail_tokens() function to return an array
   of the tokens available for the email notification messages it sends when
   accounts are created, activated, blocked, etc. Contributed modules that
   wish to make use of the same tokens for their own needs are encouraged
   to use this function. */

/* TODO
   There is a new hook_watchdog in core. This means that contributed modules
   can implement hook_watchdog to log Drupal events to custom destinations.
   Two core modules are included, dblog.module (formerly known as watchdog.module),
   and syslog.module. Other modules in contrib include an emaillog.module,
   included in the logging_alerts module. See syslog or emaillog for an
   example on how to implement hook_watchdog.
function example_watchdog($log = array()) {
  if ($log['severity'] == WATCHDOG_ALERT) {
    mysms_send($log['user']->uid,
      $log['type'],
      $log['message'],
      $log['variables'],
      $log['severity'],
      $log['referer'],
      $log['ip'],
      format_date($log['timestamp']));
  }
} */

/* TODO Implement the hook_theme registry. Combine all theme registry entries
   into one hook_theme function in each corresponding module file.
function gmap_shapes_theme() {
  return array(
  );
} */

/* TODO You may want to take advantage of new form-specific alter hooks.
   The hook_form_alter() is complemented by hook_form_$form-id_alter().
   Optionally, modules can implement form-specific alteration functions rather
   than a single hook_form_alter() with many conditional switch statements.
   This is optional, and is most useful for tidying the code of modules that
   alter many forms to customize a site's operations.
   The new function names are built using the following format:
   [your-module-name]_form_[$form_id]_alter. */

/**
 * Display help and module information
 * @param path whitch path of the site we're displaying help
 * @param arg array that holds the current path as vould be returned from arg() function
 * @return help text for the path
 */
function gmap_shapes_help($path, $arg) {
  $output = '';
  switch ($path) {
    case "admin/modules#gmap_shapes":
    case "admin/help#gmap_shapes":
     // $output = '<p>'. t("Displays links to created on this date") . '</p>';
      break;
    case "user/help#gmap_shapes":
      break;
  }
  return $output;
}

/**
 * Valid permissions for this module
 * @return array An array of valid permissions for the gmap_shapes module
 */
function gmap_shapes_perm() {
  return array('access gmap_shapes content', 'create poly');
}

/**
 * Implementation of hook_field_info().
 */
function gmap_shapes_field_info() {
  return array(
    'gmap_shapes' => array('label' => t('GoogleMap Shapes')),
  );
}


/**
 * Implementation of hook_field_settings().
 */
function gmap_shapes_field_settings($op, $field) {
  switch ($op) {
    case 'database columns':
      $columns = array(
        'gmap_shapes' => array('type' => 'GEOMETRY'),
      );
      return $columns;
  }
}


/**
 * Implementation of hook_field().
 */
function gmap_shapes_field($op, &$node, $field, &$node_field, $teaser, $page) {
  $db_info = content_database_info($field);
  switch ($op) {
    case 'insert':
    case 'update':
    // save if it's not a point, otherwise ignore
    if ($field['widget']['type'] == 'gmap_shapes') {
        // TT - ***********  -  @FIX - this is a horrible security risk from Miika's code, but i've no idea how to improve. Run through some kind of input check?
        // putting code that a user can mess with directly into the databse is really bad.
        $data = $_SESSION['gmap_shapes_save_data'];
        $data = filter_xss(check_plain($data)); // a slight security improvement, stops xss on IE6 at least
        $data_type = $_SESSION['gmap_shapes_type'];
        if (check_plain($data_type) == 'line') {
          $input_type = 'linestring';
        }
        else {
          $input_type = 'polygon';
        }

        if ($data) {
          // if there's any shape/line data then put it in the database
          if ($field['multiple']) {
            // TODO: multiple field behavior
          }
          else {
            // how to tell between POLYGON and LINESTRING for geomfromtext
            if ($input_type == 'polygon') {
              if (db_result(db_query('SELECT COUNT(*) FROM {'. $db_info['table'] .'} WHERE vid = %d AND nid = %d', $node->vid, $node->nid))) {
                db_query("UPDATE {". $db_info['table'] ."} SET ". $db_info['columns']['gmap_shapes']['column'] ." = GeomFromText('POLYGON((". $data ."))') WHERE vid = %d AND nid = %d", $node->vid, $node->nid);
              }
              else {
                db_query("INSERT INTO {". $db_info['table'] ."} (". $db_info['columns']['gmap_shapes']['column'] .", vid, nid) VALUES (GeomFromText('POLYGON((". $data ."))') , %d, %d)", $node->vid, $node->nid);
              }
            }
            else if($input_type == 'linestring'){
              if (db_result(db_query('SELECT COUNT(*) FROM {'. $db_info['table'] .'} WHERE vid = %d AND nid = %d', $node->vid, $node->nid))) {
                db_query("UPDATE {". $db_info['table'] ."} SET ". $db_info['columns']['gmap_shapes']['column'] ." = GeomFromText('LINESTRING(".$data.")') WHERE vid = %d AND nid = %d", $node->vid, $node->nid);
              }
              else {
                db_query("INSERT INTO {". $db_info['table'] ."} (". $db_info['columns']['gmap_shapes']['column'] .", vid, nid) VALUES (GeomFromText('LINESTRING(".$data.")') , %d, %d)", $node->vid, $node->nid);
              }
            }
          }
        }
        // Empty the relevent sessions information
        $_SESSION['gmap_shapes_save_data'] = '';
        $_SESSION['gmap_shapes_save_data'] = null;
        unset($_SESSION['gmap_shapes_save_data']);
        session_unregister('gmap_shapes_save_data');
        $_SESSION['gmap_shapes_type'] = '';
        $_SESSION['gmap_shapes_type'] = null;
        unset($_SESSION['gmap_shapes_type']);
        session_unregister('gmap_shapes_type');
        // TT - Unset the contents of the field so that the default CCK module doesn't mess with it
        $node_field = NULL;
        $field = NULL;
    }
    break;
  }
}

/**
 * Implementation of hook_widget_info().
 */
function gmap_shapes_widget_info() {
  return array(
    'gmap_shapes' => array(
      'label' => 'Textfield',
      'field types' => array('gmap_shapes'),
    ),
  );
}

/**
 * Implementation of hook_widget().
 */
// this is a field while creating new content
function gmap_shapes_widget($op, &$node, $field, &$items) {
  $db_info = content_database_info($field);
  switch ($op) {

  // "form": The node is being edited, and a form should be prepared for display to the user.
    case 'form':
      // check if we've got a shape
      $shape = NULL;
      if($node->nid){
        $shape = gmap_shapes_identify_type($node->taxonomy);
      }
      if($_GET[poly] == 'line'){ $shape = 'line'; }
      else if($_GET[poly] == 'area'){ $shape = 'area'; }

      // build form for widget
      $form = array();
      $form[$field['field_name']] = array(
        '#tree' => TRUE,
        '#weight' => $field['widget']['weight'],
      );

      if ($field['widget']['type'] == 'gmap_shapes') {
        // issue with multiple values?? how we should deal with them?

        // single value
        if ($field['multiple']) {
          //TODO: multiple fields features
        }else {

            // TT - create a field to choose between point, line, or shape
            $form[$field['field_name']]['gmap_type'] = array(
              '#type' => 'radios',
              '#title' => t('What are you adding'),
              '#default_value' => $shape ? $shape : 'point',
              '#id' => 'gmap_type_radios',
              '#attributes' => array('class' => 'gmap_type_radios'),
              '#options' => array(
                'point' => t('A Site'),
                'line' => t('A Line'),
                'area' => t('An Area'),
              ),
              '#access' => user_access('create poly'),

            );
            // add javascript
            drupal_add_js(drupal_get_path('module', 'gmap_shapes') . '/shapes_switcher.js');


            // TT - If user has selected shape or line, then show the map & shapefile field, else hide

            if($shape){

              // need to get lat, lon & center for map
              $gid = $_GET['gids'][0] ? $_GET['gids'][0] : $node->og_groups[0];
              $groupnode = node_load($gid);
              // pass map center  to js
              drupal_add_js(array('gmap_shapes' => array(
              'lat' => $groupnode->location['latitude'],
              'lng' => $groupnode->location['longitude'],
              'zoom' => $groupnode->field_map_zoom[0]['value'],
              )), 'setting');
              // start the main functionality
              drupal_add_js(drupal_get_path('module', 'gmap_shapes') . '/shapes.js');
              // holder for the map
              $form[$field['field_name']]['gmap_user'] = array(
                '#type'=>'markup',
                '#value'=>'',
                '#access'=>user_access('create poly'),
              );
              // help text for the map
              $form[$field['field_name']]['gmap_help'] = array(
                '#type' => 'markup',
                '#access' => user_access('create poly'),
                '#value'=>t('Click on the map to create a line or area. To complete an area click on the first point to complete the loop. To finish a line just double click in the same place. Right click (or press control and then click on a Mac) to delete a point. Once you have finished drawing you can move your mouse over the shape and drag points or click on lines to add new points. Visit the FAQ for more information'),
              );


              $form[$field['field_name']]['gmap_user']['#value'] = gmap_set_location(
                variable_get('gmap_user_map', '[gmap|id=usermap|center=0,30|control=Large|zoom=16|width=100%|height=400px]'),
                  ($lon = $_GET['edit']['gmap_longitude'] ? $_GET['edit']['gmap_longitude'] : $user->longitude),
                  ($lat = $_GET['edit']['gmap_latitude'] ? $_GET['edit']['gmap_latitude'] : $user->latitude));

              // default value for shape textfield
              if($node->nid){

                $q = "SELECT AsText(".$db_info['columns']['gmap_shapes']['column'].") AS value FROM {".$db_info['table']."} where vid = %d AND nid = %d";
                $result = db_query($q,$node->vid, $node->nid);
                $row = db_fetch_object($result);
                preg_match_all("/([^,( ]+)[ ]+([^,) ]+)/",$row->value,$matches,PREG_SET_ORDER);

                // TODO ********** FIX for lines

                if($shape == 'area') {

                  $data  = "<?xml version='1.0' encoding='UTF-8'?>\n" .
                       "<kml>\n" .
                       "<Document>\n" .
                       "<Placemark>\n" .
                       "<Polygon>\n" .
                       "<outerBoundaryIs>\n" .
                       "<LinearRing>\n" .
                       "<coordinates>\n";
                  for($i =0;$i < count($matches);$i++){
                      if($i != 0){$data .= " ";}
                      $data .= $matches[$i][1] . "," . $matches[$i][2];
                  }

                  $data .= "</coordinates>\n" .
                       "</LinearRing>\n" .
                       "</outerBoundaryIs>\n" .
                       "</Polygon>\n" .
                       "</Placemark>\n" .
                       "</Document>\n" .
                       "</kml>\n";

                } else {

                   $data  = "<?xml version='1.0' encoding='UTF-8'?>\n" .
                       "<kml>\n" .
                       "<Document>\n" .
                       "<Placemark>\n" .
                       "<LineString>\n" .
                       "<coordinates>\n";
                  for($i =0;$i < count($matches);$i++){
                      if($i != 0){$data .= " ";}
                      $data .= $matches[$i][1] . "," . $matches[$i][2];
                  }

                  $data .= "</coordinates>\n" .
                       "</LineString>\n" .
                       "</Placemark>\n" .
                       "</Document>\n" .
                       "</kml>\n";

                }

                $shape_textfield_default_value = $data;
              }else {
                $shape_textfield_default_value = "";
              }

              // shape textfield
              $form[$field['field_name']][0]['gmap_shapes'] = array(
                    '#type' => 'textarea',
                    '#title' => $field['widget']['label'],
                    '#id' => 'gmap_shapes_textfield',
                    //  '#disabled' => TRUE,
                    '#default_value' => $shape_textfield_default_value,
                    '#required' => $field['required'] ? $field['required'] : FALSE,
                    '#size' => isset($field['widget']['size']) ? $field['widget']['size'] : 60,
                    '#description' => isset($field['widget']['description']) ? $field['widget']['description'] : '',
                    '#access' => user_access('create poly'),
                  );
            }
        }

      }
      return $form;

  // "submit": The user has just finished editing the node and the node has passed validation. This hook can be used to modify the node.
  case 'submit':
    if ($field['widget']['type'] == 'gmap_shapes') {
      if($node->{$field['field_name']}[0]['gmap_shapes'] != ''){
        $shape = parseXMLToArray($node->{$field['field_name']}[0]['gmap_shapes']);
        // first we are looking for a polygons
        $polygons = _getShapeArraysByTagname('POLYGON',$shape);

        // now look for lines
        $lines = _getShapeArraysByTagname('LINESTRING',$shape);

        if($polygons){
          // saves only the firs one of the polygons
          $coordinates = _getShapeArraysByTagname('COORDINATES',$polygons[0]);
          $_SESSION['gmap_shapes_type'] = 'polygon';
        } else if ($lines) {
          $coordinates = _getShapeArraysByTagname('COORDINATES',$lines[0]);
          $_SESSION['gmap_shapes_type'] = 'line';
        }

        // we haveto put data to mysql recognisable format
        preg_match_all("/([^, ]+),([^, ]+)/",$coordinates[0]['value'],$matches,PREG_SET_ORDER);
        $data = '';
        for($i =0;$i < count($matches);$i++){
            if($i != 0){$data .= ",";}
            $data .= $matches[$i][1] . " " . $matches[$i][2];
        }

        $node->{$field['field_name']}[0]['gmap_shapes'] = $data;
        $items[0]['gmap_shapes'] = $data;


        $items = array();
        $_SESSION['gmap_shapes_save_data'] = $data;

        $field = NULL;
        $items = NULL;

      }
    }


  return;
  }
}


/**
 * parseXMLToArray
 * @param $data String
 * @return array
 * This function parses given XML data to the array where tree format still exists.
 */
function parseXMLToArray($data) {

    $a = array();
      $xml_parser = xml_parser_create();
    /*
     * xml_parser = parser,
     * data = data to be parsed,
     * vals = array which will contain value-data after this function call,
     * index = array which will contain index-data after this function call
     */
      xml_parse_into_struct($xml_parser, $data, $vals, $index);
    xml_parser_free($xml_parser);

    // st = root of the whole array
    $st = array('childs' => array());
    $parent = &$st; // parent = parent array of current element
    $parent_stack = array(); // stack of the parent arrays (needed when closing elements)
    $parent_stack[] = &$parent;

    foreach ($vals as $xml_elem) {

      if($xml_elem['type'] == "open") {
        $ind = count($parent['childs']);

        $parent['childs'][$ind] = array(
        'tag' => $xml_elem['tag'],
        'value' => $xml_elem['value'],
        'childs' => array(),
        );

        // attributes for the element
             if ($xml_elem['attributes']) {
               $parent['childs'][$ind]['attributes'] = array();
                 foreach($xml_elem['attributes'] as $attrKey => $attrVal){
                   $parent['childs'][$ind]['attributes'][$attrKey] = $attrVal;
                 }
             }
        // when element is open we make it a parent item and add it to the stack
        // we are not using array_push because we need a link to the original array not just a copy of it
        $parent = &$parent['childs'][$ind];
        $parent_stack[] = &$parent;

         } elseif($xml_elem['type'] == "close") {
        // we do not want to use array_pop method to get parent element because we need a link to the original array not just a copy of it
        array_pop($parent_stack);
        $parent = &$parent_stack[count($parent_stack)-1];

         } elseif($xml_elem['type'] == "complete") {
        $ind = count($parent['childs']);

        $parent['childs'][$ind] = array(
        'tag' => $xml_elem['tag'],
        'value' => $xml_elem['value'],
        // complete elements are leaves so we don't need 'childs' array
        );

        // attributes for the element
             if ($xml_elem['attributes']) {
               $parent['childs'][$ind]['attributes'] = array();
                 foreach($xml_elem['attributes'] as $attrKey => $attrVal){
                   $parent['childs'][$ind]['attributes'][$attrKey] = $attrVal;
                 }
             }
         }

       }
    //$a = $st['childs'];
    $a = $st;
    return $a;

}
/**
 * _getShapeArraysByTagname
 * @return Array on success else FALSE
 * @param $tag String
 * @param $array Array
 * @param $r Array[optional]
 * Iterative function which returns an array of all arrays with requested tag
 */
function _getShapeArraysByTagname($tag, $array, &$r = array()){

  // if given array is not an array return false
  if(!is_array($array)){
    return FALSE;
  }

  // if given array is empty it is useless to continue
  if(count($array) == 0){
    return FALSE;
  }

  // if current array matches we add it to the return array
  if(isset($array['tag']) && strtoupper($array['tag']) == strtoupper($tag)) {
    $r[] = $array;
  }

  // we are reading each of the childs through
  if(is_array($array['childs'])){
    while(list($k,$v) = each($array['childs'])){
      // iteration
      _getShapeArraysByTagname($tag, $array['childs'][$k], $r);
    }
  }

  // if no matches return false
  if(count($r) == 0){
    return FALSE;
  } else {
    return $r;
  }
}

/**
 * Implementation of hook_field_formatter_info().
 *
 */
function gmap_shapes_field_formatter_info() {
  return array(
    'default' => array(
      'label' => 'Default Gmap Shape',
      'field types' => array('gmap_shapes'),
    ),
  );
}


/*
 select * from shape where MBRIntersects(data,GeomFromText('LineString(4 4,5 5)'));
 */





/**
 *  hook_form_alter()
 *
 *  If the user has selected to add a line or area, then we need to hide normal location form
 */
function gmap_shapes_form_alter(&$form, &$form_state, $form_id){
  switch ($form_id) {
    case 'green_site_node_form':
      $shape = NULL;
      // if we're editing a form, check if it's a shape
      if($form['#node']->nid){
        $shape = gmap_shapes_identify_type($form['#node']->taxonomy);
      }
      if($_GET[poly] == 'point'){
        $js = "var poly_type = 'point';";
        drupal_add_js($js, 'inline');
        // hide non-used taxonomies
        $form['taxonomy']['5'] = NULL;
        // TODO secondary

      } else if($_GET[poly] == 'line' || $_GET[poly] == 'area' || $shape){
        // print_r($form);
        if($_GET[poly] == 'line' || $shape == 'line'){
          $js = "var poly_type = 'line';";
          drupal_add_js($js, 'inline');
          $shape = 'line';
        } else {
          $js = "var poly_type = 'area';";
          drupal_add_js($js, 'inline');
          $shape = 'area';
        }

        //  hide the wrong taxonomies, make required primaryicon not required
        $form['taxonomy']['1']['#required'] = 0;
        $form['taxonomy']['5']['#required'] = 1;

        // make the lines/shapes taxonomy a bit nicer

        if ($shape == 'line') {
          $terms = taxonomy_get_tree(5,305);
        } else {
          $terms = taxonomy_get_tree(5,306);
        }

        foreach($terms as $term) {
          if ($term->depth == 0) {
            // ???
          } else {
            $parent = taxonomy_get_term($term->parents[0]);
            $options[$parent->name][$term->tid] = $term->name;
          }
        }
        $form['taxonomy'][5]['#options'] = $options;

        // hide the default location form
        $form['locations']=NULL;

      } else {
        $js = "var poly_type = 'point';";
        drupal_add_js($js, 'inline');
        // hide non-used taxonomies
        $form['taxonomy']['5'] = NULL;
        // TODO secondary
      }

      break;
    case 'green_map_node_form':
      $form['field_use_poly']['#access'] = user_access('create poly');
      break;
  }
}

/* this figures out if we've got a line or polygon based on the node's taxonomy
* @param taxonomy - an array containing objects with tid, vid, etc
* @return - $shape - a string - either 'line' or 'area'
*/

function gmap_shapes_identify_type($taxonomy){
  foreach($taxonomy as $tid => $term){
    if($term->vid == 5){
      $term_tid = $tid;
      break;
    }
  }
  $parents = taxonomy_get_parents($term_tid); // an array of parent term objects
  foreach($parents as $parent){
    $parent_term = taxonomy_get_parents($parent->tid);
  }

  $parent_term = array_values($parent_term);

  if ($parent_term[0]->tid == 306){
    return 'area';
  } elseif ($parent_term[0]->tid == 305){
    return 'line';
  } else {
    return NULL;
  }

}

/*
 * Build the key for the lines & areas
 */

function gmap_shapes_key_build($node) {
  // currently ignoring the $node object - just building  a key containing all lines & areas

  // get the taxonomy
  $terms = taxonomy_get_tree(5);

  // get array containing colors (key of array is the tid) - function is in gmap_marker.module line 840 and could use some work
  $colors = gmap_marker_load_poly_colors();

  // get array containing widths (key of array is the tid) - function is in gmap_marker.module line 850 and could use some work
  $widths = gmap_marker_load_poly_opacitys();

  // loop through taxonomy turning it into an un-ordered nested list
  $key = getKeyList($terms, 'poly', $colors);

  return $key;
}
